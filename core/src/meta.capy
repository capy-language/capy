
core :: #mod("core");
fmt :: core.fmt;

// returns the underlying bit representation of the type id.
meta_to_raw :: (ty: type) -> u32 #builtin("meta_type_to_u32");

Layout :: struct {
    size: usize,
    align: usize,
};

array_layouts : [] Layout : #builtin("array_layouts");
distinct_layouts : [] Layout : #builtin("distinct_layouts");
struct_layouts : [] Layout : #builtin("struct_layouts");
enum_layouts : [] Layout : #builtin("enum_layouts");
variant_layouts : [] Layout : #builtin("variant_layouts");
optional_layouts : [] Layout : #builtin("optional_layouts");
error_union_layouts : [] Layout : #builtin("error_union_layouts");

pointer_layout : Layout : #builtin("pointer_layout");

// The amount of space a type takes up in memory.
//
// i8 takes 1 byte to store, i32 takes four bytes.
//
// For structs it is the size of all the fields in a struct, plus any padding between those fields.
// (see `align_of` for more info on padding/alignment)
//
// The size of this struct,
//
// struct {
//     a: i64, // 8 bytes (align = 8)
//     b: i32, // 4 bytes (align = 4)
// }
//
// would be 12 bytes
//
// The size of this struct,
//
// struct {
//     a: i32, // 4 bytes (align = 4)
//     // 4 bytes of padding here
//     b: i64, // 8 bytes (align = 8)
// }
//
// would be 16 bytes
// 
// If you need to store multiple structs in a row (as in an array or buffer),
// `stride_of` is the function to use
size_of :: (ty: type) -> usize {
    ty := meta_to_raw(ty);

    // the discriminant is the leftmost 6 bits
    discriminant := ty >> 26;

    // all the discriminants < 16 are simple
    // (they contain all relevant information as bit flags)
    if discriminant < 16 {
        // the first 5 bits in a simple type id are the size
        usize.(ty & 0b11111)
    } else {
        // about 5 types have complex id's
        // (they contain only a discriminant and an index)

        layouts := if discriminant == struct_discriminant {
            struct_layouts
        } else if discriminant == distinct_discriminant {
            distinct_layouts
        } else if discriminant == enum_discriminant {
            enum_layouts
        } else if discriminant == variant_discriminant {
            variant_layouts
        } else if discriminant == array_discriminant {
            array_layouts
        } else if discriminant == slice_discriminant {
            return pointer_layout.size * 2;
        } else if discriminant == optional_discriminant {
            optional_layouts
        } else if discriminant == error_union_discriminant {
            error_union_layouts
        } else {
            core.assert(
                discriminant == pointer_discriminant ||
                discriminant == function_discriminant,
                "called size_of on an unknown type with a discriminant of ",
                discriminant
            );
            // the size is the same for both of these types
            return pointer_layout.size;
        };

        // removes the discriminant (6 bits)
        index := ty &~ (0b111111 << 26);

        layouts[index].size
    }
}

// The stride of a type is the space allocated for a single element in an array.
//
// Imagine a struct like so:
//
// struct {
//     a: i64, // 8 bytes (align = 8)
//     b: i32, // 4 bytes (align = 4)
// }
//
// The size of this struct is 12 bytes and its alignment is 8.
// If we naively allocated an array for this struct using its size (12 bytes), it would look like this,
//
// 0          12         24         36
// [    s    ][    s    ][    s    ]
//
// But wait! This struct's alignment is 8 and the second element of this array starts on address 12.
// 12 is not a multiple of 8, and some architectures might complain if try to access the second field.
// So some padding needs to be added in between our structs.
//
// The "stride" of a type is the size plus the padding needed for the next struct.
// For our example, it would be 12 bytes plus the padding needed to bring that size to the next multiple of 8.
//
// In memory, an array which allocates using stride would look like this:
//
// 0          12   16         28   32         44   48
// [    s    ][ p ][    s    ][ p ][    s    ][ p ]
//
// As you can see, all of the structs in the array start at addresses which are multiples of 8 (0, 16, 32).
//
// So when allocating space for arrays/buffers, allocate n * stride_of(T).
stride_of :: (ty: type) -> usize {
    mask := align_of(ty) - 1;
    (size_of(ty) + mask) &~ mask
}

// Most types must appear in addresses that are a multiple of a certain "alignment".
// This is a restriction of the underlying architecture.
//
// The alignment of `i16` is 2, so a value of type `i16`
// can only exist on addresses which are multiples of 2.
// If we put an `i16` on a bad address, some architectures might complain.
//
// For example, take the following struct,
//
// struct {
//     a: i8,  // 1 byte  (align = 1)
//     b: i16, // 2 bytes (align = 2)
// }
//
// If we naively laid this struct out in memory it'd look like this:
//
// 0    1    2    4
// [ a ][    b    ]
//
// But wait! `b` (which is an `i16`) starts at address 1, but that isn't a multiple of 2.
// Our computer isn't going to like this!
// 
// In order to ensure that `b` starts at an address which is a multiple of 2,
// the compile will have to add padding to the struct,
//
// struct {
//     a: i8,       // 1 byte
//     padding: i8, // 1 byte  (this is a secret, hidden field)
//     b: i16,      // 2 bytes
// }
//
// Now the struct looks like this in memory:
//
// 0    1    2    4    5
// [ a ][   ][    b    ]
//        ^
//        |
//        \  padding here
//
// As you can see, `b` now starts at address 2, which is a multiple of its alignment (2).
//
// The alignment of a struct is the largest alignment of all its fields
//
// struct {
//     a: i64, // 8 bytes (align = 8)
//     b: i16, // 2 bytes (align = 2)   
// }
// 
// This struct's alignment is 8, so this struct can only appear in addresses which are multiples of 8.
//
// An alignment of `1` is accepted in all addresses (every number is a multiple of 1)
align_of :: (ty: type) -> usize {
    ty := meta_to_raw(ty);

    // the discriminant is the leftmost 6 bits
    discriminant := ty >> 26;

    // all the discriminants < 16 are simple
    // (they contain all relevant information as bit flags)
    if discriminant < 16 {
        // the second 4 bits in a simple type id are the alignment
        usize.((ty >> 5) & 0b1111)
    } else {
        // about 5 types have complex id's
        // (they contain only a discriminant and an index)

        layouts := if discriminant == struct_discriminant {
            struct_layouts
        } else if discriminant == distinct_discriminant {
            distinct_layouts
        } else if discriminant == enum_discriminant {
            enum_layouts
        } else if discriminant == variant_discriminant {
            variant_layouts
        } else if discriminant == array_discriminant {
            array_layouts
        } else if discriminant == optional_discriminant {
            optional_layouts
        } else if discriminant == error_union_discriminant {
            error_union_layouts
        } else {
            core.assert(
                discriminant == slice_discriminant ||
                discriminant == pointer_discriminant ||
                discriminant == function_discriminant,
                "called align_of on an unknown type with a discriminant of ",
                discriminant
            );
            // the align is the same for both of these types
            return pointer_layout.align;
        };

        // removes the discriminant (6 bits)
        index := ty &~ (0b111111 << 26);

        layouts[index].align
    }
}

// simple type ids
// (they contain all relevant information as bit flags)
void_discriminant : u8 : 1;
int_discriminant : u8 : 2;
float_discriminant : u8 : 3;
bool_discriminant : u8 : 4;
string_discriminant : u8 : 5;
char_discriminant : u8 : 6;
meta_type_discriminant : u8 : 7;
any_discriminant : u8 : 8;
file_discriminant : u8 : 9;
raw_ptr_discriminant : u8 : 10;
raw_slice_discriminant : u8 : 11;
nil_discriminant : u8 : 12;

// complex type ids
// (they contain an index into a global type info array)
struct_discriminant : u8 : 16;
distinct_discriminant : u8 : 17;
array_discriminant : u8 : 18;
slice_discriminant : u8 : 19;
pointer_discriminant : u8 : 20;
function_discriminant : u8 : 21;
enum_discriminant : u8 : 22;
variant_discriminant : u8 : 23;
optional_discriminant : u8 : 24;
error_union_discriminant : u8 : 25;

Type_Info :: enum {
    // `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
    // `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
    //
    // `usize` and `isize` have the same size as a pointer on the target architecture.
    Int: struct {
        bit_width: u8,
        signed: bool,
    }           | int_discriminant,
    // `f32`, `f64`
    Float: struct {
        bit_width: u8,
    }           | float_discriminant,
    // `bool`
    Bool        | bool_discriminant,
    // `str`
    String      | string_discriminant,
    // `char`
    Char        | char_discriminant,
    // `[6] i32`
    // `[10] u8`
    // ...
    //
    // A standard array of data, laid out linearly in memory.
    Array: struct {
        len: usize,
        sub_ty: type,
    }           | array_discriminant,
    // `[] i8`
    // `[] char`
    // ...
    //
    // The slice. A reference to an array of any size. It contains only a pointer to the array, and the length of the array.
    Slice: struct {
        sub_ty: type,
    }           | slice_discriminant,
    // `^i32`
    // `^bool`
    // ...
    Pointer: struct {
        sub_ty: type,
        mutable: bool,
    }           | pointer_discriminant,
    // `distinct i32`
    // `distinct bool`
    // ...
    //
    // The distinct, A unique type with the same underlying semantics of its sub-type
    Distinct: struct {
        sub_ty: type,
    }           | distinct_discriminant,
    // `struct { a: i32, b: i32 }`
    // `struct { foo: str }`
    // ...
    Struct: struct {
        members: []Member_Info,
    }           | struct_discriminant,
    // `enum { Foo, Bar }`
    // `enum { Number: i32, Text: str, Condition: bool }`
    // ...
    Enum: struct {
        variants: []type,
        discriminant_offset: usize,
    }           | enum_discriminant,
    // `enum { Foo, Bar }`
    // `enum { Number: i32, Text: str, Condition: bool }`
    // ...
    // 
    // `Foo`, `Bar`, `Number`, etc. are actually their own unique types,
    // very similar to distinct types. They have the same underlying
    // semantics of their sub-type.
    //
    // Unlike a regular distinct type, enum variants also contain info about the discriminant
    Variant: struct {
        sub_ty: type,
        discriminant: u32,
    }           | variant_discriminant,
    // `nil`
    //
    // Like void, nil is its own type. This allows you to do `?void` which internally is a tagged union of `void` or `nil`
    Nil         | nil_discriminant,
    // `?u64`
    // `?str`
    // ...
    //
    // Represents the possibility of missing/empty/unfilled data.
    //
    // Options, along with error unions can be used with the `.try` and `catch {}` operators
    //
    // Technical Details:
    // 0 is always the nil discriminant
    // 1 is always the payload discriminant
    //
    // Optional pointers are the same size as regular pointers, and the `nil` state is internally a NULL pointer
    Optional: struct {
        sub_ty: type,
        // indicates that the inner type is a non-zero type, and the `nil` state of this optional is represented by a value of 0
        is_non_zero: bool,
        discriminant_offset: usize,
    }           | optional_discriminant,
    // `str!u64`
    // `My_Error_Enum!bool`
    // ...
    //
    // A type used for returning and propagating errors in your program.
    // The error type goes on the left and can be whatever you want, although an enum is recommended.
    //
    // Error unions, along with options can be used with the `.try` and `catch {}` operators
    //
    // Technical Details:
    // 0 is always the error discriminant
    // 1 is always the payload discriminant
    Error_Union: struct {
        error_ty: type,
        payload_ty: type,
        discriminant_offset: usize,
    }           | error_union_discriminant,
    // `() -> void`
    // `(x: i32) -> bool`
    // ...
    //
    // a function type looks the same as an actual function except that it lacks a body `{ }`
    Function    | function_discriminant,
    // the file type
    //
    // when `#mod("core")`, or `#import("file.capy")` are used as values, their type is `file`.
    // no two `file` types are the same, `#import("a.capy")` and `#import("b.capy")` are really two unique types.
    //
    // If you're saying "this is a strange way to implement first-class imports", then you're probably right :)
    File        | file_discriminant,
    // `type`
    //
    // a "meta type". types are first-class values and `i32` when used as a value has the type of `type`
    Meta_Type   | meta_type_discriminant,
    // `any`
    // 
    // can represent any arbitrary but unknown value.
    // internally `any` contains a `rawptr` and a `type`
    Any         | any_discriminant,
    Raw_Ptr: struct {
        mutable: bool,
    }           | raw_ptr_discriminant,
    Raw_Slice   | raw_slice_discriminant,
    // `void`
    //
    // an empty type, a `u0`
    Void        | void_discriminant,
};

array_infos : []Type_Info.Array : #builtin("array_infos");
slice_infos : []Type_Info.Slice : #builtin("slice_infos");
pointer_infos : []Type_Info.Pointer : #builtin("pointer_infos");
distinct_infos : []Type_Info.Distinct : #builtin("distinct_infos");
struct_infos : []Type_Info.Struct : #builtin("struct_infos");
enum_infos : []Type_Info.Enum : #builtin("enum_infos");
variant_infos : []Type_Info.Variant : #builtin("variant_infos");
optional_infos : []Type_Info.Optional : #builtin("optional_infos");
error_union_infos : []Type_Info.Error_Union : #builtin("error_union_infos");

get_type_info :: (ty: type) -> Type_Info {
    raw := meta_to_raw(ty);

    discrim := raw >> 26;

    if discrim == int_discriminant {
        Type_Info.Int.{
            // the first five bits is the size in bytes
            bit_width = u8.((raw & 0b11111) * 8),
            // the ninth bit is the sign flag
            signed = bool.((raw >> 9) & 1),
        }
    } else if discrim == float_discriminant {
        Type_Info.Float.{
            // the first five bits is the size in bytes
            bit_width = u8.((raw & 0b11111) * 8),
        }
    } else if discrim == bool_discriminant {
        Type_Info.Bool
    } else if discrim == string_discriminant {
        Type_Info.String
    } else if discrim == char_discriminant {
        Type_Info.Char
    } else if discrim == array_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        array_infos[idx]
    } else if discrim == slice_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        slice_infos[idx]
    } else if discrim == pointer_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        pointer_infos[idx]
    } else if discrim == distinct_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        distinct_infos[idx]
    } else if discrim == struct_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        struct_infos[idx]
    } else if discrim == enum_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        enum_infos[idx]
    } else if discrim == variant_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        variant_infos[idx]
    } else if discrim == function_discriminant {
        Type_Info.Function
    } else if discrim == file_discriminant {
        Type_Info.File
    } else if discrim == meta_type_discriminant {
        Type_Info.Meta_Type
    } else if discrim == any_discriminant {
        Type_Info.Any
    } else if discrim == raw_ptr_discriminant {
        Type_Info.Raw_Ptr.{
            // the ninth bit is the mutable flag
            mutable = bool.((raw >> 9) & 1),
        }
    } else if discrim == raw_slice_discriminant {
        Type_Info.Raw_Slice
    } else if discrim == void_discriminant {
        Type_Info.Void
    } else if discrim == nil_discriminant {
        Type_Info.Nil
    } else if discrim == optional_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        optional_infos[idx]
    } else if discrim == error_union_discriminant {
        // removes the discriminant (6 bits)
        idx := raw &~ (0b111111 << 26);

        error_union_infos[idx]
    } else {
        core.unreachable(
            "\nunknown type id when calling `get_type_of`:",
            "\nraw = 0b", fmt.binary(raw),
            "\ndiscrim = ", discrim,
            "\nidx = ", raw &~ (0b111111) << 26
        );

        // todo: add a `noreturn` type so values don't have to be returned like this
        Type_Info.Void
    }
}

// A member within a struct e.g. `foo` in `struct { foo: str }`
Member_Info :: struct {
    name: str,
    ty: type,
    offset: usize,
};

