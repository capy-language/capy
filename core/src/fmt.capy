
// todo: I want to do smth more like zig's `allocPrint` and `bufPrint`
// https://github.com/ziglang/zig/blob/905c85be968e6823305887474d2a821dac82f16c/lib/std/fmt.zig#L1436

core :: #mod("core");
ptr :: core.ptr;
math :: core.math;
string_builder :: core.string_builder;

StringBuilder :: string_builder.StringBuilder;

Number_Formatting :: struct {
    number: i64,
    base: u64,
    signed: bool,
};

binary :: (n: i64) -> Number_Formatting {
    Number_Formatting.{
        number = n,
        base = 2,
        signed = true,
    }
}

binary_unsigned :: (n: u64) -> Number_Formatting {
    Number_Formatting.{
        number = ^i64.(rawptr.(^n))^, // transmute u64 -> i64
        base = 2,
        signed = false,
    }
}

hex :: (n: i64) -> Number_Formatting {
    Number_Formatting.{
        number = n,
        base = 16,
        signed = true,
    }
}

hex_unsigned :: (n: u64) -> Number_Formatting {
    Number_Formatting.{
        number = ^i64.(rawptr.(^n))^, // transmute u64 -> i64
        base = 16,
        signed = false,
    }
}

decimal :: (n: i64) -> Number_Formatting {
    Number_Formatting.{
        number = n,
        base = 10,
        signed = true,
    }
}

decimal_unsigned :: (n: u64) -> Number_Formatting {
    Number_Formatting.{
        number = ^i64.(rawptr.(^n))^, // transmute u64 -> i64
        base = 10,
        signed = false,
    }
}

/// takes in a number with formatting and returns how big the resulting string would be
int_string_len :: (n: Number_Formatting) -> usize {
    if n.number == 0 {
        return 1;
    }

    negative := n.signed && n.number < 0;

    number := if negative {
        u64.(-1) &~ u64.(n.number) + 1
    } else {
        u64.(n.number)
    };
    base   := n.base;

    // log_10(1)  == 0
    // log_10(10) == 1
    // etc.
    // therefore +1 is needed
    digits := if base == 2 {
        core.math.log2_u64(number) + 1
    } else if base == 10 {
        core.math.log10_u64(number) + 1
    } else {
        u64.(core.math.ln(f64.(number)) / core.math.ln(f64.(base)) + 1)
    };

    if negative {
        digits += 1; // +1 for minus sign
    }

    digits
}


int_to_string :: (n: Number_Formatting) -> StringBuilder {
    core.assert(n.base <= 62, "only bases up to 62 are supported");

    // lena's version of this function was much better than mine so I'm just gonna get rid of mine and add a few extra things to her's
    negative := n.signed && n.number < 0;

    number := if negative {
        u64.(-1) &~ u64.(n.number) + 1
    } else {
        u64.(n.number)
    };

    base     :: n.base;

    digits   := int_string_len(n);
    core.assert(digits >= 1, "digits should be at least one");

    str := string_builder.make_with_capacity(digits);
    str.len = digits;

    // don't try and do anything for index 0 if the number is negative
    while digits > u32.(negative) {
        remainder :: number % u64.(base);
        number    =  number / u64.(base);
        digits    =  digits - 1;

        zero_to_nine :: u8.('9') - u8.('0');
        a_to_z       :: zero_to_nine + u8.('z') - u8.('a');
        A_to_Z       :: a_to_z + u8.('Z') - u8.('A');

        ch := if remainder <= zero_to_nine {
            u8.('0') + u8.(remainder)
        } else if remainder <= a_to_z + 1 {
            u8.('a') + u8.(remainder - zero_to_nine - 1)
        } else if remainder <= A_to_Z + 2 {
            u8.('A') + u8.(remainder - a_to_z - 2)
        } else {
            core.todo("bases this high are not yet supported");
            0
        };

        ptr.write(#unwrap(str.buf), ch, digits);
    }

    if negative {
        ptr.write(
            #unwrap(str.buf),
            u8.('-'),
            0
        );
    }

    str
}

iprint :: (n: i64) {
    n := n;
    
    if n < 0 {
        n = -n;
        core.libc.putchar('-');
    }

    if n > 9 {
        a := n / 10;

        n -= 10 * a;
        iprint(a);
    }
    core.libc.putchar(char.(u8.('0') + n));
}

precision               : f64   : 0.00000000000001;
max_number_string_size  : usize : 32;

float_string_len :: (n: f64) -> usize {
    // todo: do something smart
    max_number_string_size
}

dec_part :: (val: f64) -> i64 {
    mult := i64.(math.floor(val));
    val := val;

    while math.floor(val) != math.ceil(val) {
        mult *= mult;
        val *= val;
    }

    i64.(math.floor(val)) - mult
}

float_to_string :: (n: f64) -> StringBuilder {
    if math.is_NaN(n) {
        res := string_builder.make_with_capacity(3);
        string_builder.append_str(^mut res, "NaN");
        return res;
    } else if n == math.positive_inf {
        res := string_builder.make_with_capacity(4);
        string_builder.append_str(^mut res, "+Inf");
        return res;
    } else if n == math.negative_inf {
        res := string_builder.make_with_capacity(4);
        string_builder.append_str(^mut res, "-Inf");
        return res;
    } else if n == 0.0 {
        res := string_builder.make_with_capacity(3);
        string_builder.append_str(^mut res, "0.0");
        return res;
    }

    afterpoint : usize : 3;

    float_digits := float_string_len(n);
    res := string_builder.make_with_capacity(float_digits);

    ipart := i64.(math.floor(n));
    front := int_to_string(decimal(ipart));
    string_builder.append_string_builder(^mut res, ^front);
    string_builder.free(^mut front);

    string_builder.append_char(^mut res, '.');

    fpart := n - f64.(ipart);
    fpart *= f64.(math.pow_i32(10, i32.(afterpoint)));
    fpart := decimal(i64.(fpart));

    digits := int_string_len(fpart);

    while afterpoint - digits > 0 {
        string_builder.append_char(^mut res, '0');
        digits += 1;
    }

    decimal := int_to_string(fpart);
    string_builder.append_string_builder(^mut res, ^decimal);
    string_builder.free(^mut decimal);

    // this is to make sure `float_to_string` is accurate
    core.assert(res.cap == float_digits, res.cap, " != ", float_digits);

    res
}
