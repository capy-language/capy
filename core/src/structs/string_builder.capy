core :: #mod("core");
libc :: core.libc;
math :: core.math;
ptr :: core.ptr;

StringBuilder :: struct {
    buf: ?^mut char,
    len: usize,
    cap: usize,
};

make :: () -> StringBuilder {
    // this gets populated with a default zero-value.
    // normally, structs with pointer fields can't have defaults,
    // but since we're using an optional pointer this works
    empty_builder: StringBuilder;
    
    empty_builder
};

make_with_capacity :: (cap: usize) -> StringBuilder {
    if cap == 0 {
        return make();
    }

    buf := ?^mut char.(libc.malloc(cap));

    if cap > 0 && buf == nil {
        core.panic("Error allocating the StringBuilder");
    }

    StringBuilder.{
        buf = buf,
        len = 0,
        cap = cap,
    }
}

free :: (self: ^mut StringBuilder) {
    libc.free(self.buf);
    // to make sure the string isn't accidentally used after free
    self.cap = 0;
    self.len = 0;
}

shrink_to_fit :: (self: ^mut StringBuilder) {
    if self.len != 0 && self.len < self.cap {
        self.buf = ?^mut char.(libc.realloc(self.buf, self.len));
        self.cap = self.len;

        if self.cap > 0 && self.buf == nil {
            core.panic("Error reallocating the StringBuilder");
        }
    }
}

_grow_by :: (self: ^mut StringBuilder, len: usize) {
    if self.len + len > self.cap {
        new_cap := math.max_usize(self.cap * 2, 1);
        new_cap = math.max_usize(
            math.next_pow_of_two(self.len + len), 
            new_cap
        );

        self.buf = ?^mut char.(libc.realloc(self.buf, new_cap));
        self.cap = new_cap;

        if self.buf == nil {
            core.panic("Error reallocating the StringBuilder");
        }
    }
}

append_char :: (self: ^mut StringBuilder, ch: char) {
    _grow_by(self, 1);

    // we just grew the buffer, so we can safely unwrap
    ptr.write(#unwrap(self.buf), u8.(ch), self.len);

    self.len = self.len + 1;
}

append_str :: (self: ^mut StringBuilder, s: str) {
    len :: core.str_len(s);

    _grow_by(self, len);

    if self.buf == nil {
        return;
    }
    buf := #unwrap(self.buf);

    offset := ptr.mut_offset(buf, self.len);

    libc.memcpy(offset, rawptr.(s), len);
    
    self.len = self.len + len;
}

append_string_builder :: (self: ^mut StringBuilder, other: ^StringBuilder) {
    if other.buf == nil {
        return;
    }
    other_buf := #unwrap(other.buf);

    _grow_by(self, other.len);

    // we just grew so this is safe
    self_buf := #unwrap(self.buf);

    offset := ptr.mut_offset(self_buf, self.len);

    libc.memcpy(offset, other_buf, other.len);
    
    self.len = self.len + other.len;
}

reverse :: (self: ^mut StringBuilder) {
    if self.buf == nil {
        return;
    }
    buf := #unwrap(self.buf);

    i := 0;
    j := self.len - 1;
    temp := 0;

    while i < j {
        temp = ptr.read(buf, i);
        ptr.write(buf, ptr.read(buf, j), i);
        ptr.write(buf, temp, j);
        i += 1;
        j -= 1;
    }
}

to_slice :: (self: ^mut StringBuilder) -> [] char {
    switch buf in self.buf {
        ^mut char => [] char.(ptr.slice_from_raw_parts(buf, self.len)),
        nil => [] char.(ptr.empty_slice()),
    }
}

print :: (self: ^StringBuilder) {
    idx := 0;
    while idx < self.len {
        // if we're in this loop, it means the buf must have a value
        buf := #unwrap(self.buf);
        ch := char.(ptr.read(buf, idx));
        libc.putchar(ch);
        idx += 1;
    }
}

println :: (self: ^StringBuilder) {
    print(self);
    libc.putchar('\n');
}
